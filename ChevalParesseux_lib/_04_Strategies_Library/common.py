import pandas as pd
import numpy as np
from abc import ABC, abstractmethod
from joblib import Parallel, delayed
from typing import Union, Self
import uuid



#! ==================================================================================== #
#! ====================================== Base Model ================================== #
class Strategy(ABC):
    """
    Base class for all strategies.
    
    This class is used to define the common methods and attributes for all strategies.
    Each strategy should inherit from this class and implement the abstract methods. Also, they should
    always have a similar output format, which is a list of DataFrames where each DataFrame corresponds 
    to the 'signals_df' of an asset (contains basic asset information, signals, and size information).
    
    signals_df is a DataFrame that contains the following columns:
        - 'code': Unique identifier for the asset.
        - 'signal': The signal generated by the strategy.
        - 'size': The size of the position to take based on the signal.
        - 'date': timestamp of the signal.
        - A price column (e.g., 'close', 'open', 'ask_open', etc.) that contains the price of the asset at the time of the signal.
    """
    #?_____________________________ Initialization methods _______________________________ #
    @abstractmethod
    def __init__(
        self, 
        n_jobs: int = 1,
    ) -> None:
        """
        Constructor for the Strategy class.
        
        Parameters:
            - n_jobs (int): The number of jobs to run in parallel, default is 1.
        """
        # ======= I. Jobs =======
        self.n_jobs = n_jobs

    #?____________________________________________________________________________________ #
    @abstractmethod
    def set_params(
        self,
        **kwargs
    ) -> Self:
        """
        Sets the parameters of the strategy.
        
        This method should be implemented by each strategy to set its specific parameters.
        Usually, we want the parameters to be feed independenly inside the strategy and store them in a 
        dictionary or similar structure.
        We specifically want to avoid losing tracks of which parameters are to be used for which strategy.
        
        Parameters:
            - **kwargs: Keyword arguments representing the parameters to be set for the strategy.
        
        Returns:
            - Self: Returns the instance of the strategy with the updated parameters.
        """
        ...  

    #?________________________________ Auxiliary methods _________________________________ #
    @abstractmethod
    def process_data(
        self,
        data: Union[tuple, pd.Series, pd.DataFrame],
        **kwargs
    ) -> Union[tuple, pd.DataFrame, pd.Series]:
        """
        Preprocesses the data before strategy extraction.
        
        The input data can be a tuple, a pandas Series, or a DataFrame depending on the strategy.
        The output should be a processed version of the input data, ready for strategy extraction.
        
        Parameters:
            - data (Union[tuple, pd.Series, pd.DataFrame]): The input data to preprocess.
            - **kwargs: Additional parameters for preprocessing.
            
        Returns:
            - Union[tuple, pd.DataFrame, pd.Series]: The preprocessed data.
        """
        ...
    
    #?____________________________________________________________________________________ #
    @abstractmethod
    def extract(
        self,
        data: Union[tuple, pd.Series, pd.DataFrame],
        **kwargs
    ) -> Union[list, pd.DataFrame]:
        """
        Extract signals from the data using the strategy.
        
        This method should be implemented by each strategy to extract signals from the input data.
        It should return a list of DataFrames or a single DataFrame, where each DataFrame corresponds to the 'signals_df' of an asset.
        The DataFrame should contain the following columns:
            - 'code': Unique identifier for the asset.
            - 'signal': The signal generated by the strategy (e.g., buy, sell, hold).
            - 'size': The size of the position to take based on the signal.
            - 'date': Timestamp of the signal.
            - A price column (e.g., 'close', 'open', 'ask_open', etc.) that contains the price of the asset at the time of the signal.
        
        Parameters:
            - data (Union[tuple, pd.Series, pd.DataFrame]): The input data to extract signals from.
            - **kwargs: Additional parameters for extraction.
        
        Returns:
            - Union[list, pd.DataFrame]: A list of DataFrames or a single DataFrame containing the extracted signals.
        """
        ...
